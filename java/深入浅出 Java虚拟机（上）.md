
Java是一个跨平台的语言，不同平台对应不同的JVM，JVM执行(Java源代码经过编译后的)字节码，保证了同样的字节码可以在不同平台运行。

JVM Java虚拟机，以Sun HotSpot为例，该JVM基于C++，JVM说白了就是一个进程，比如Linux平台的HotSpot本质上就是一个C++进程，这个进程是linux上的进程，所以，linux的api是可以在进程中直接(被JVM)使用的。

JVM里面提供了一套指令集，隐藏了底层的CPU指令集，首先功能实现上是完整的。其次，在JVM中也实现了一套内存管理模型，底层当然是基于linux的内存相关的API实现的，对于JVM上层的Java应用来说，底层的内存管理细节都被隐藏在JVM中了。然后是一些系统级的API实现，比如线程，文件系统等，整个套路都是JVM提供一个抽象的硬件无关的规范，底层都是映射到linux中的实现（linux thread，file system等）。

## JVM内存管理机制
<img src="./_image/深入浅出 Java虚拟机（上）/18-53-38.jpg"/>

Java运行时数据区域被划分为几块，不同的区域功能不同。

- **方法区**：与堆类似，是各个线程共享的区域，用于存储被JVM加载的类信息、常量、静态变量、字节码等数据。
- **堆**：线程共享区域，几乎所有的对象实例都存储在该区域。
- **虚拟机栈**：执行Java方法时用。
- **本地方法栈**：调用Native方法时用。
-  **程序计数器**：执行Java字节码的行号指示器，表示代码执行到哪里了。每个线程都有一个程序计数器。注意，如果执行的是native代码，则该计数器值为空。这里的程序计数器的功能和操作系统概念中CPU的PC寄存器是类似的。

### HtoSpot JVM对象揭秘

Java是面向对象语言，运行过程中无时无刻进行着对象的创建操作，语言层面上对象创建也就是new操作而已，对象（普通Java对象，不包括数组和Class对象）的创建过程是怎么样的呢？

虚拟机遇到new执行时，首先检查是否能在常量池中定位到一个类的符号引用，并判断该符号引用对应的类是否加载过，如果没有则执行加载操作，一个类从加载到结束使用的流程是：加载、连接（验证/准备/解析）、初始化、使用、卸载。一个类的大小在加载完成之后就可以确定了，会占用堆内存的一块空间。假如JVM堆是规整的，已分配内存放在一边，未分配内存放在另一边，分配内存仅仅是把分配指针（已分配/未分配临界点）移动下位置而已，这种方式称为“指针碰撞”，C中malloc一块(小)内存的原理就是指针碰撞。还有一种分配方式称为空闲列表，也就是空闲内存可能物理上不连续，分配时从该空闲内存列表中获取一块内存即可。

在堆上内存分配是很频繁的行为，堆是面向所有线程的，这就需要考虑多线程的并发操作问题了。一般有2种方案，一种是对内存分配动作进行同步处理，实际上JVM采用CAS加上失败重试保证操作的原子性；另一种是每个线程都预先划分一块不同的内存空间，分配动作首先在自己所属的内存空间上操作，这个称为本地线程分配缓冲（TLAB）。

对象的内存分配完成后，从JVM角度来一个对象就创建OK了，但是从程序角度来看，对象还未进行初始化呢。初始化动作就是`<cinit>`方法，它的逻辑就是类的static属性和static代码的逻辑。 在执行类的构造方法之前，会调用`<init>`方法，它就是类的属性和实例块代码的逻辑了。

### 对象的内存布局

HotSpot对象创建OK后，对象在内存中的布局分为3个区域：对象头、实例数据和对齐填充。对象头主要包括2部分信息，一个存储自身运行时数据，如哈希吗、GC分代年龄、锁状态标志、锁等信息；另一个是类型指针，及对象的类元数据的指针，通过这个知道对象属于哪个类的实例。实例数据也就是对象真正的数据信息。对齐填充不是必须的，对象的地址要求是8字节的整数倍，如果不满足则需对齐填充处理。

new对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体对象。 由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、 访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。 目前主流的访问方式有使用句柄和直接指针两种。

如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息：
<img src="./_image/深入浅出 Java虚拟机（上）/18-54-23.jpg"/>

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址：
<img src="./_image/深入浅出 Java虚拟机（上）/18-54-38.jpg"/>

这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。Sun HotSpot使用的直接指针方式。

## 垃圾回收

Java和C/C++之间有一堵墙，即内存动态分配和垃圾回收技术所构建的围墙，墙外面的人想进去，墙里面的人想出来。

### 垃圾判定算法

Java堆中存放着几乎所有的对象实例，垃圾收集器在对堆进行回收前，首先需要确定哪些对象还"活着"，哪些已经"死亡"，也就是不会被任何途径使用的对象。

**引用计数法**

引用计数法实现简单，效率较高，大部分情况下是一个不错的算法。其原理是：给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1，当计数器值为0时表示该对象不再被使用。需要注意的是：引用计数法很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用引用计数法来管理内存。

**可达性分析法**

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则说明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。
<img src="./_image/深入浅出 Java虚拟机（上）/18-55-03.jpg"/>

### 对象的4种引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

- **强引用**就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- **软引用**是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。
- **弱引用**也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
- **虚引用**也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

### 垃圾回收算法

**Mark-Sweep（标记-清除）算法**

这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。 注意，该算法容易产生内存碎片，碎片过多会导致后续过程无法为大对象分配空间，导致提前触发gc动作。
<img src="./_image/深入浅出 Java虚拟机（上）/18-55-26.jpg"/>

**Copying（复制）算法**

为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：
<img src="./_image/深入浅出 Java虚拟机（上）/18-56-02.jpg"/>

**Mark-Compact（标记-整理）算法**

为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：
<img src="./_image/深入浅出 Java虚拟机（上）/18-56-29.jpg"/>

**Generational Collection（分代收集）算法**

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。
[JVM中新生代为什么要有两个Survivor（form,to）？](https://www.zhihu.com/question/44929481/answer/98252991)

## 垃圾收集器

首先来看一下JVM的新生代和老年代中所有的垃圾收集器全家福，如果两个收集器之间存在连线，就说明它们可以搭配使用。注意：垃圾收集器没有优劣之分，只有在具体场景下合适不合适之说。
<img src="./_image/深入浅出 Java虚拟机（上）/18-57-23.jpg"/>

**(1) Serial收集器**

Serial收集器是最基本、 发展历史最悠久的收集器，曾经（在JDK 1.3之前）是虚拟机新生代收集器的唯一选择。 大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 “StopThe World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。
<img src="./_image/深入浅出 Java虚拟机（上）/18-58-21.jpg"/>
到现在为止，Serial依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

**(2) ParNew收集器**

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、 -XX：PretenureSizeThreshold、 -XX：HandlePromotionFailure等）、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。
<img src="./_image/深入浅出 Java虚拟机（上）/19-02-15.jpg"/>

**(3) Parallel Scavenge收集器**

Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，类似于ParNew？Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

**(4）Serial Old收集器**

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。 这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生ConcurrentMode Failure时使用。
<img src="./_image/深入浅出 Java虚拟机（上）/19-02-43.jpg"/>

**（5）Parallel Old收集器**

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。 原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。 由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。
<img src="./_image/深入浅出 Java虚拟机（上）/19-03-07.jpg"/>

**（6）CMS收集器**

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 CMS收集器就非常符合这类应用的需求。

从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：
-  初始标记（CMS initial mark）
-  并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。

<img src="./_image/深入浅出 Java虚拟机（上）/19-03-45.jpg"/>

CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、 低停顿， 但是CMS还远达不到完美的程度，它有以下3个明显的缺点：
- CMS收集器对CPU资源非常敏感。
- CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent ModeFailure”失败而导致另一次Full GC的产生，浮动垃圾只能等到下次GC收集。
- CMS是一款基于“标记—清除”算法实现的收集器，会产生内存碎片问题。
空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

**（7）G1收集器**

G1是一款面向服务端应用的垃圾收集器。 HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。 目前Java9的默认GC收集器就是G1，证明G1的高性能和高可靠性。与其他GC收集器相比，G1具备如下特点。

- **并行与并发**：G1能充分利用多CPU、 多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- **分代收集**：与其他收集器一样，分代概念在G1中依然得以保留。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、 熬过多次GC的旧对象以获取更好的收集效果。
- **空间整合**：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
- **可预测的停顿**：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。