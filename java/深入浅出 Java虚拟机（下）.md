
## Class文件

我们都知道Java是跨平台，那么它能够实现跨平台的原理是什么呢？也就是字节码（class文件中的数据），字节码是Java实现平台无关性的基石。JVM不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件绑定，Class文件包含了Java虚拟机指令集和符号表及若干其他辅助信息。JVM的无关性包括：平台无关性和语言无关性。

<img src="./_image/深入浅出 Java虚拟机（下）/23-40-27.jpg"/>

### Class文件结构

任何一个Class文件都对应着唯一一个类或接口的信息(这里的类包括抽象类哈)，但反过来，类或接口信息并不一定都定义在文件里（比如类或接口可通过类加载器动态生成，Spring中AOP的实现中就有可能由类加载器动态生成代理类）。Class文件是一组以8字节为基础单位的二进制文件，各个数据项严格按照顺序紧凑着排列，中间没有任何分隔符，也就是说整个Class文件存储的几乎都是程序运行所需的必要数据。

根据JVM规范，Class文件格式采用一种类似C语言结构体的伪结构体来存储数据，这种伪结构体中只有2种数据类型：无符号数和表，无符号和表的关系类似于C语言中基本类型与结构体的关系。无符号数属于基本类型，以u1/u2/u4/u8来表示1个字节/2个字节/4个字节/8个字节，无符号数可用来描述数字、索引引用、数量值或按照UTF-8编码的字符串。表是由多个无符号数或者其他表构成的复合数据类型，习惯以"_info"结构，表用于描述有层次关系的复合数据类型，整个Class文件本质上就是一个大的表。

<img src="./_image/深入浅出 Java虚拟机（下）/23-41-18.jpg"/>

Class文件中都包含那些信息呢？Class文件按照顺序排列都包括：
- 魔数与Class文件版本：CAFEBABE
- 常量池：Class文件的资源仓库
- 访问标志：标识类或接口的访问信息
- 类索引、父类索引、接口索引集合：类的继承关系信息
- 字段表集合：描述接口或类中声明的变量字段信息
- 方法表集合：描述接口或类中定义的方法信息
- 属性表集合：描述某些场景专有的信息

## JVM栈帧结构

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。 栈帧存储了方法的局部变量表、 操作数栈、 动态连接和方法返回地址等信息。 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

每一个栈帧都包括了局部变量表、 操作数栈、 动态连接、 方法返回地址和一些额外的附加信息。 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

<img src="./_image/深入浅出 Java虚拟机（下）/23-42-02.jpg"/>

### 局部变量表

局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在该方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、 byte、 char、 short、 int、 float、 reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出“每个Slot占用32位长度的内存空间”是有一些差别的，它允许Slot的长度可以随着处理器、 操作系统或虚拟机的不同而发生变化。 只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。 其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。

### 操作数栈

操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In FirstOut,LIFO）栈。 同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。 操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。 在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。 例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈（与其对应的是，可以说机器码是基于寄存器来计算的）。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。 我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。 这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。 另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。

### 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法。 第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。

另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。 一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。

## 方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。 在程序运行时，进行方法调用是最普遍、 最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。 这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

### 解析

继续前面关于方法调用的话题，所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、 编译器进行编译时就必须确定下来。 这类方法的调用称为解析（Resolution）。

在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其版本，因此它们都适合在类加载阶段进行解析。

与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。
- invokestatic：调用静态方法。
- invokespecial：调用实例构造器＜init＞方法、 私有方法和父类方法。
- invokevirtual：调用所有的虚方法。
- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、 私有方法、 实例构造器、 父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。 这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法，后文会提到）。 Java中的非虚方法除了使用invokestatic、 invokespecial调用的方法之外还有一种，就是被final修饰的方法。 虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。 在Java语言规范中明确说明了final方法是一种非虚方法。

解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。 而分派（Dispatch）调用则可能是静态的也可能是动态的。

### 分派

众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继承、 封装和多态。 本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，我们关心的依然是虚拟机如何确定正确的目标方法。

**静态分派**

静态分派即我们所说的重载：
```Java
static class Base { }
static class Derived extends Base { }
 
public static void test(Base base) {
    System.out.println("test Base");
}
public static void test(Derived derived) {
    System.out.println("test Derived");
}
 
public static void main(String[] args) {
    Base base = new Base();
    Base derived = new Derived();
 
    test(base);
    test(derived);
}
```

我们把上面代码中的“Base”称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的“Derived”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

代码中刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。 并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 静态分派的典型应用是方法重载。 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。 另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。 

### 动态分派

了解了静态分派，我们接下来看一下动态分派的过程，它和多态性的另外一个重要体现——重写（Override）有着很密切的关联。
```Java
static class Base {
    public void test() {
        System.out.println("Base test");
    }
}
static class Derived extends Base {
    public void test() {
        System.out.println("Derived test");
    }
}
 
public static void main(String[] args) {
    Base base = new Base();
    Base derived = new Derived();
 
    base.test();
    derived.test();
}
```

现在的问题还是和前面的一样，虚拟机是如何知道要调用哪个方法的？显然这里不可能再根据静态类型来决定，因为静态类型同样都是Base的两个变量base和derived在调用test()方法时执行了不同的行为，并且变量在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？

### 动态分派的实现原理

前面介绍的分派过程，作为对虚拟机概念模型的解析基本上已经足够了，它已经解决了虚拟机在分派中“会做什么”这个问题。 但是虚拟机“具体是如何做到的”，可能各种虚拟机的实现都会有些差别。

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。 面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。 我们先看看一种类继承关系的虚方法表结构示例，如图所示：

<img src="./_image/深入浅出 Java虚拟机（下）/23-45-59.jpg"/>

虚方法表中存放着各个方法的实际入口地址。 如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。 如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。图中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。 但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。
为了程序实现上的方便，具有相同签名的方法，在父类、 子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。 **方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。**

Java的方法表和C++中的虚表思想是一样的，C++每个类也有一个对应的虚函数表，并且对象中有一个指针指向该虚函数表，Java的虚方法表是存放在类方法区中的。不过这两者有个不同的地方是，Java对象在创建时其对应的方法表就固定了，而C++对象在创建时其对应的虚方法表是变化的（在对象创建时会经过2个流程，初始化父类区域时虚表指针指向的是父类的虚方法表，初始化子类区域时虚方法表指针指向的是子类的虚方法表）。下面以一个示例说明：

Java示例代码，父类构造方法和子类构造方法都调用了动态方法。
```Java
public class Base {
    public Base() {
        test();
    }
 
    public void test() {
        System.out.println("Base test()...");
    }
}
 
public class Derived extends Base {
    public Derived() {
        test();
    }
 
    public void test() {
        System.out.println("Derived test()...");
    }
}
 
public static void main(String[] args) {
    Derived derived = new Derived();
}
```
输出结果如下：
```Java
Derived test()...
Derived test()...
```

C++示例代码，父类构造函数和子类构造函数都调用了动态方法。
```C++
class Base
{
public:
    Base() {
        test();
    }
 
    virtual void test() {
        cout << "Base test()..." << endl;
    }
};
 
class Derived : public Base
{
public:
    Derived() {
        test();
    }
 
    virtual void test() {
        cout << "Derived test()..." << endl;
    }
};
 
int main(int argc, char **argv)
{
    Derived derived;
 
    return 0;
}
```
输出结果如下：
```C++
Base test()...
Derived test()...
```

## JVM类加载机制

类加载也就是JVM"读取"class文件，"class文件"不一定是以文件方式存储在磁盘的，也可能是从网络中接收到的二进制流，class由.java文件经过JDK编译而来，将源码编译为class文件的实现取决于各个JVM实现或各个编译器实现。class文件按照固定的格式来存储数据并且通常由类加载器来完成加载；class的执行在Sun JDK中有解释执行和编译为机器码执行两种方式；JVM的运行模式又分为server模式和client模式。

### Class文件结构

JVM实现平台无关性的关键就是使用了统一的存储结构--字节码，实现语言无关性的关键是虚拟机和字节码存储格式，Java虚拟机不和任何语言绑定，而只于class文件绑定，class文件包含了Java虚拟机指令集和符号表及若干其他信息。JVM无关性包括平台无关性和语言无关性。

<img src="./_image/深入浅出 Java虚拟机（下）/23-48-16.jpg"/>

任何一个Class都对应着唯一一个类或接口的信息(这里的类包括抽象类哈)，但反过来，类或接口信息并不一定都定义在文件里（比如类或接口可通过类加载器动态生成，Spring中AOP的实现中就有可能由类加载器动态生成代理类）。Class文件是一组以8字节为基础单位的二进制文件，各个数据项严格按照顺序紧凑着排列，中间没有任何分隔符，也就是说整个Class文件存储的几乎都是程序运行所需的必要数据。

那么class文件中都包含那些信息呢？class文件按照顺序排列都包括：
- 魔数与Class文件版本：CAFEBABE
- 常量池：Class文件的资源仓库
- 访问标志：标识类或接口的访问信息
- 类索引、父类索引、接口索引集合：类的继承关系信息
- 字段表集合：描述接口或类中声明的变量字段信息
- 方法表集合：描述接口或类中定义的方法信息
- 属性表集合：描述某些场景专有的信息

### 类加载机制

目前已经知道了class文件结构，但是class文件是什么时候才加载的呢，被什么加载的呢？虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、 转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行连接工作的语言不同，比如C/C++语言，它们的.c或者.cpp文件编译成可执行文件需要经过预处理、编译、汇编、连接等流程，这些流程缺一不可。而在Java语言里，类型的加载、 连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。 从最基础的Applet、 JSP到相对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、 验证（Verification）、 准备（Preparation）、 解析（Resolution）、 初始化（Initialization）、 使用（Using）和卸载（Unloading）7个阶段。 其中验证、 准备、 解析3个部分统称为连接（Linking），这7个阶段的发生顺序如图所示。

<img src="./_image/深入浅出 Java虚拟机（下）/13-37-04.jpg"/>

对于什么时候进行类加载操作，JVM规范中并没有严格规定，这点由虚拟机自行实现。但对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、 验证、 准备自然需要在此之前开始）：
- 遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
- 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
对于以上5种情况会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。 除此之外，所有引用类的方式都不会触发初始化(也就是不会进行类加载)，称为被动引用。

被动引用是什么，以下情况都属于被动引用的情况：
- 通过子类引用父类的静态字段，不会导致子类的初始化。
- 通过数组定义来引用类，不会触发该类的初始化。
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量类的初始化。

注意，在一个类初始化的时候，要求其父类都已经初始化，但是一个接口在初始化的时候，并不要求其父接口全部都初始化，只有在真正使用到父接口的时候(比如引用父接口中常量)才会初始化。在一个类初始化的时候，并不要求其数据域所有对象都初始化，只有在在真正设置数据域对象时才会进行初始化。

**类加载流程**

类加载流程主要有5个阶段：
- 加载：通过一个类的全限定名来获取定义此类的二进制字节流，然后将该字节流所代表的的静态存储结构转换为方法区运行时数据结构，在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 验证：验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。这也是相对于C/C++来说，Java语言本身相对安全的原因。
- 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 注意，这里的类变量指的是类中被static修饰的变量，它们在该阶段都会被初始化对应的“零值”。
- 解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用是在Class文件结构的常量池中的东西。
- 初始化：类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。 到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值（零值），而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。

**什么是<clinit>()方法**

＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。 因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。由于父类的＜clinit＞()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。 但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。 只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。

虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、 同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。 如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 （比如类A中static块有while死循环，两个线程都进行new A()操作，则第二个进入类A的<clinit>()方法的线程会被阻塞）

**类加载器与双亲委任模型**

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、 isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。

### 双亲委任模型

JVM的类加载的实现方式称为双亲委任模型，其流程是当收到一个类加载请求时，首先会交给父加载器完成，如果父加载器反馈自己无法加载时，子加载器才尝试自己完成加载，每一层次的类加载器都是如此。

从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（Sun JVM就是由C++实现的），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

从Java程序员角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。

- 启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。
- 扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。 它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

注意，Java程序都是由以上3种类加载相互配合进行加载的，如果有必要，还可以加入自定义的类加载器。

<img src="./_image/深入浅出 Java虚拟机（下）/13-39-45.jpg"/>

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。

**双亲委任模型好处**

解决了类加载过程中的安全性问题，如果定义了一个Java基础类库中的一个类，使用双亲委任模型保证了Java基础类的加载由上层类加载器优先加载。

### 破坏双亲委任模型

双亲委任模型并不是一个强制性的模型，而是Java推荐开发者的类加载器实现方式，双亲委任模型实现逻辑在loadClass方法中。
```Java
protected synchronized Class<?> loadClass(String name,boolean resolve)throws ClassNotFoundException{
    //check the class has been loaded or not
    Class c = findLoadedClass(name);
    if(c == null){
        try{
            if(parent != null){
                c = parent.loadClass(name,false);
            }else{
                c = findBootstrapClassOrNull(name);
            }
        }catch(ClassNotFoundException e){
            //if throws the exception ,the father can not complete the load
        }
        if(c == null){
            c = findClass(name);
        }
    }
    if(resolve){
        resolveClass(c);
    }
    return c;
}
```

JDK1.2之后不提倡用户再去覆盖loadClass方法，而应该把自己的类加载逻辑写到findClass()中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass方法来完成加载，这样可以保证新写出来的类加载器是符合双亲委任模型的。

双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。**如果基础类又要调用回用户的代码，那该么办**？一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。

为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。


